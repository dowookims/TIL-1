2019년 1월 29일 화요일

# 함수와 프로토타입 체이닝

## 1. 함수 정의

#### 함수 생성 방법

1. 함수 선언문 function statement
2. 함수 표현식 function expression
3. Function() 생성자 함수

이들 방식은 모두 같은 함수를 생성하지만, 각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.

먼저 함수 선언문과 함수 표현식에서 함수를 생성하는 _함수 리터럴_ 의 개념을 먼저 살펴보자.



### 1.1 함수 리터럴

자바스크립트에서 함수도 _일반 객체_ 처럼 값으로 취급된다. 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, __함수 리터럴__ 을 이용해 함수를 생성할 수 있다. 함수 선언문과 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 선언한다.

```javascript
function add(x, y) {
    return x + y;
}
```

1. `function` 키워드 : 자바스크립트 함수 리터럴은 `function` 키워드로 시작한다.

2. 함수명 `add`

   함수명은 함수 몸채의 내부 코드에서 자신을 재귀적으로 호출하거나 자바스크립트 디버거가 해당 함수를 구분하는 식별자로 사용된다. 여기서 주목할 점은 __함수명은 선택 사항__ 이라는 것이다. 자바스크립트에서 _함수명이 없는 함수_ 를 _익명 함수_ 라 한다.

3. 매개변수 리스트 `(x, y)` : 매개변수 타입을 기술하지 않는다.

4. 함수 몸체 : 실제 함수가 호출됐을 때 실행되는 코드 부분이다.



### 1.2 함수 선언문 방식으로 함수 생성하기

함수 선언문 방식은 앞서 설명한 함수 리터럴 형태와 같다. 주의할 점은 함수 선언문 방식으로 정의된 함수의 경우 __반드시 함수명이 정의되어 있어야 한다__ 는 것이다.

```javascript
// add() 함수 선언문
function add(x, y) {
    return x + y;
}

console.log(add(3, 4));	// 7
```



### 1.3 함수 표현식 방식으로 함수 생성하기

자바스크립트에서는 함수도 _하나의 값_ 처럼 취급된다. (이러한 특징으로 인해 _일급 객체_ 로 불리기도 한다.) 따라서 함수도 숫자나 문자열처럼 _변수에 할당_ 하는 것이 가능하다.

이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 __함수 표현식__ 이라고 말한다.

```javascript
// add() 함수 표현식 (익명 함수를 변수 add에 할당)
var add = function(x, y) {
    return x + y;
};

var plus = add;

console.log(add(3, 4));		// 7
console.log(plus(5, 6));	// 11
```

__함수 변수__ `add` 가 실제로 참조하는 두 수를 더하는 함수의 이름이 없다. 이렇게 이름이 없는 함수 형태를 __익명 함수__ 라고 부른다.  즉, 위의 코드는 __익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)__ 이다.

참고로, 함수 이름이 포함된 함수 표현식을 __기명 함수 표현식__ 이라 한다.

```javascript
var add = function sum(x, y) {
    return x + y;
};

console.log(add(3, 4));		// 7
console.log(sum(3, 4));		// Uncaught ReferenceError
```

함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능하다는 사실에 주의해야 한다.

함수 표현식에서 함수 이름은 선택 사항이지만, 이러한 함수 이름을 사용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능해진다.

```javascript
var factorialVar = function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

console.log(factorialVar(3));	// 6
console.log(factorial(3));		// undefined
```



#### [참고] 함수 선언문과 함수 표현식에서의 세미콜론

일반적으로 _함수 선언문 방식으로 선언된 함수_ 의 경우 _세미콜론을 붙이지 않지만_, _함수 표현식 방식_ 의 경우 _세미콜론을 붙이는 것을 권장_ 한다.



### 1.4 Function() 생성자 함수를 통한 함수 생성하기

자바스크립트의 함수도 `Function()` 이라는 기본 내장 생성자 함수로부터 생성된 __객체__ 라고 볼 수 있다. 앞서 설명한 함수 선언문이나 함수 표현식 방식은 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로는 `Function()` 생성자 함수로 함수가 생성된다고 볼 수 있다.

`Function()` 생성자 함수로 함수를 생성하는 문법은ㅇ 다음과 같다.

```javascript
new Function (arg1, arg2, ... argN, functionBody)
/* arg1, arg2, ... argN : 함수의 매개변수
   functionBody : 함수가 호출될 때 실행될 코드를 포함한 문자열 */
```

이 방식을 사용해서 작성한 `add()` 함수는 다음과 같다.

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3, 4));	// 7
```



### 1.5 함수 호이스팅

지금까지 자바스크립트에서 함수를 생성하는 3가지 방법을 살펴봤다. 모두 같은 기능의 함수를 생성하지만 이들의 동작 방식에는 약간의 차이가 있다. 그중 하나가 바로 __함수 호이스팅__ 이다.

자바스크립트 Guru로 알려진 더글러스 크락포트는 함수 생성에 있어서 그의 저서 "더글라스 크락포드의 자바스크립트 핵심 가이드"(2008, 한빛미디어)에서 _함수 표현식_ 만을 사용할 것을 권하고 있다. 그 이유 중 하나가 바로 함수 호이스팅 때문이다.

```javascript
add(2, 3);	// 5	- 1

// 함수 선언문 형태로 add() 함수 정의	- 2
function add(x, y) {
    return x + y;
}

add(3, 4);	// 7	- 3
```

1. 아직 이 시점에서는 함수가 정의되지 않았음에도 `add()` 함수를 호출하는 것이 가능하다. 이것은 함수가 자신이 위치한 코드에 상관없이 __함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다__ 는 것을 확인할 수 있다. 이것을 __함수 호이스팅__ 이라 부른다.

더글러스는 이러한 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적하며, 함수 표현식 사용을 권장하고 있다.

```javascript
add(2, 3);	// uncaught type error	- 1

// 함수 표현식 형태로 add() 함수 정의	- 2
var add = function(x, y) {
    return x + y;
};

add(3, 4);	// 7					- 2
```

1. `add()` 함수는 2에서 함수 표현식 형태로 정의되어 있어 __호이스팅이 일어나지 않는다.__ 따라서 3과 같이 함수가 생성된 이후에 호출이 가능하다.



이러한 함수 호이스팅이 발생하는 원인은 자바스크립트의 __변수 생성(Instantiation)__ 과 __초기화(Initialization)__ 의 작업이 분리돼서 진행되기 때문이다.



## 2. 함수 객체 : 함수도 객체다

### 2.1 자바스크립트에서는 함수도 객체다

자바스크립트에서는 __함수도 객체__ 다. 즉, 함수의 기본 기능인 코드 실행뿐만 아니라 함수 자체가 _일반 객체처럼 프로퍼티들을 가질 수 있다_ 는 것이다.

```javascript
// 함수 선언문 방식으로 add() 함수 정의 - 1
function add(x, y) {
    return x + y;
}

// add() 함수 객체에 프로퍼티 추가		- 2
add.result = add(3, 2);
add.status = 'OK';

console.log(add.result);	// 5
console.log(add.status);	// 'OK'
```

1. `add()` 함수를 생성할 때 함수 코드는 함수 객체의 __`[[Code]]` 내부 프로퍼티__ 에 자동으로 저장된다. 

2. 일반 객체처럼 `add()` 함수에 프로퍼티를 동적으로 생성한다.
3. 일반 객체처럼 프로퍼티에 접근한다.



### 2.2 자바스크립트에서 함수는 값으로 취급된다.

앞서 설명한 것처럼 자바스크립트에서 함수는 객체다. 이는 __함수도 일반 객체처럼 취급될 수 있다__ 는 것을 말한다. 때문에 자바스크립트 함수는 다음과 같은 동작이 가능하다.

* 리터럴에 의해 생성
* 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
* 함수의 인자로 전달 가능
* 함수의 리턴값으로 리턴 가능
* 동적으로 프로퍼티를 생성 및 할당 가능

이와 같은 특징을 가진 자바스크립트의 함수는 __일급 객체(First-class object)__ 로 불린다. 앞에서 나열한 기능이 모두 가능한 객체를 일급 객체라고 부르는데, 자바스크립트 함수가 갖는 이런 일급 객체의 특성으로 _함수형 프로그래밍_ 이 가능하다.



#### 1) 변수나 프로퍼티의 값으로 할당

함수는 숫자나 문자열처럼 _변수나 프로퍼티의 값으로 할당_ 될 수 있다.

```javascript
// 변수에 함수 할당
var foo = 100;
var bar = function() { return 100; };
console.log(bar());		// 100

// 프로퍼티에 함수 할당
var obj = {};
obj.baz = function() { return 200; };
console.log(obj.baz());	// 200
```



#### 2) 함수 인자로 전달

함수는 다른 함수의 인자로도 전달이 가능하다. `foo()`는 함수 표현식 방법으로 생성한 함수로서, 인자로 받은 `func` 함수를 내부에서 함수 호출 연산자 `()`를 붙여 호출하는 기능을 한다.

```javascript
// 함수 표현식으로 foo() 함수 생성
var foo = function(func) {
    func();	// 인자로 받은 func() 함수 호출
};

// foo() 함수 호출
foo(function() {
    console.log('Function can be used as the argument.');
});

// 출력결과
// Function can be used as the argument.
```

위 코드에서 `foo()` 함수를 호출할 때, 함수 리터럴 방식으로 생성한 __익명 함수__ 를 `func` 인자로 넘겼다. 따라서 `foo()` 함수 내부에서는 `func` 매개변수로 인자에 넘겨진 함수를 호출할 수 있다.



#### 3) 리턴값으로 활용

함수는 다른 함수의 리턴값으로도 활용할 수 있다. 다음 예제에서 `foo()`함수는 간단한 익명 함수를 리턴하는 역할을 한다. 이것이 가능한 이유 또한 함수 자체가 값으로 취급되기 때문이다.

```javascript
// 함수를 리턴하는 foo() 정의
var foo = function() {
    return function() {
        console.log('This function is the return value');
    };
};

var bar = foo();	// - 1
bar();				// - 2

// 출력결과
// This function is the return value
```

1. `foo()` 함수가 호출되면, 리턴값으로 전달되는 함수가 `bar` 변수에 저장된다.
2. `()` 함수 호출 연산자를 이용해 `bar()` 로 리턴된 함수를 실행하는 것이 가능하다.



### 2.3 함수 객체의 기본 프로퍼티

계속 강조했듯이 자바스크립트에서는 __함수 역시 객체다.__ 이것은 함수 역시 __일반적인 객체의 기능에 추가로 호출됐을 때 정의된 코드를 실행하는 기능을 가지고 있다는 것__이다. 또한, _일반 객체와는 다르게_ 추가로 __함수 객체만의 표준 프로퍼티__ 가 정의되어 있다. 

```javascript
function add(x, y) {
    return x + y;
}
console.dir(add);
```

앞의 코드를 크롬 브라우저에서 실행해보면 `add()` 함수는 `arguments`, `caller`, `length` 등과 같은 다양한 프로퍼티가 기본적으로 생성된 것을 확인할 수 있다. 이러한 프로퍼티들이 함수를 생성할 때 포함되는 _표준 프로퍼티_ 다.

ECMA5Script 명세서에는 __모든 함수가 `length`와 `prototype` 프로퍼티를 가져야 한다__ 고 기술하고 있다. 

우선, `length`나 `prototype` 이외의 `name`, `caller`, `arguments`, `__proto__` 프로퍼티를 간단히 살펴보자. 이들 프로퍼티는 __EMCA 표준이 아니다.__

* __`name` 프로퍼티__ 는 함수의 이름을 나타낸다. 예제에서는 함수명이 `add`이지만, 만약 이름이 없는 익명 함수라면 `name` 프로퍼티는 빈 문자열이 된다.

* __`caller` 프로퍼티__ 는 자신을 호출한 함수를 나타낸다. 자신을 호출한 함수가 없으면 `null` 값이 나온다.

* __`arguments` 프로퍼티__ 는 함수를 호출할 때 전달된 인자값을 나타내며 인자값이 없으면 `null` 값이 출력된다.
  * [참고] `arguments` 객체
    * 같은 이름으로 ECMA 표준에서는 __`arguments` 객체__ 를 정의하고 있다. `arguments` 객체는 함수를 호출할 때 호출된 함수의 내부로 인자값과 함께 전달되며, `arguments` 프로퍼티와 유사하게 함수를 호출할 때 전달 인자값의 정보를 제공해준다.

* **`__proto__` 프로퍼티** 

  * __3.4 프로토타입__ 에서 _모든 자바스크립트 객체는 자신의 프로토타입을 가리키는 `[[Prototype]]` 라는 내부 프로퍼티를 가진다_ 고 설명했다. 그리고 크롬 브라우저에서는 `[[Prototype]]` 이라는 내부 프로퍼티가 바로 `__proto__` 프로퍼티로 구현되어 있다. 

  

#### Function.prototype 함수 객체

* `add()` 와 같이 함수 객체의 부모 역할을 하는 프로토타입 객체를 __`Function.prorotype` 객체__ 라고 명명하고 있으며, 이것 역시 __함수 객체__ 라고 정의하고 있다. __`Function.prototype` 객체__ 는 __모든 함수들의 부모 역할__ 을 하는 프로토타입 객체다. ECMAScript 명세서에는 `Function.prototype` 함수 객체의 부모는 자바스크립트의 모든 객체의 조상격인 __`Object.prototype` 객체__ 라고 설명하고 있다.
* ECMAScript 명세서에는 이러한 `Function.prototype` 객체가 가져야 하는 프로퍼티들을 다음과 같이 기술하고 있다.
  * `constructor` 프로퍼티
  * `toString()` 메서드
  * __`apply(thisArg, argArray)` 메서드__
  * __`call(thisArg, [, arg1 [, arg2]])` 메서드__ 
  * `bind(thisArg, [, arg1 [, arg2]])`



#### 1) `length` 프로퍼티

함수 객체의 `length` 프로퍼티는 ECMAScript에서 정한 모든 함수가 가져야 하는 표준 프로퍼티로서, __함수가 정상적으로 실행될 때 기대되는 인자의 개수__ 를 나타낸다.



#### 2) `prototype` 프로퍼티

모든 함수는 객체로서 __`prototype` 프로퍼티__ 를 갖고 있다. 여기서 주의할 것은 __함수 객체의 `prototype` 프로퍼티__ 는 앞서 설명한 __모든 객체의 부모를 나타내는 내부 프로퍼티인 `[[Prototype]]`__ 과 혼동하지 말아야 한다는 것이다.

* __`prototype` 프로퍼티__ 와 __`[[Prototype]]` 프로퍼티__

  두 프로퍼티 모두 __프로토타입 객체__ 를 가리킨다는 점에서 공통점이 있지만, 관점에 차이가 있다.

  * `[[Prototype]]` (= `__proto__`) : 모든 객체에 있는 내부 프로퍼티. 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리킨다.
  * `prototype` : 함수 객체가 가지는 프로퍼티. 이 함수가 생성자로 사용될 때 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킨다.

`prototype` 프로퍼티는 함수가 생성될 때 만들어지며, 단지 __`constructor` 프로퍼티__ 하나만 있는 객체를 가리킨다. 그리고 `prototype` 프로퍼티가 가리키는 프로토타입 객체의 유일한 `constructor` 프로퍼티는 자신과 연결된 함수를 가리킨다.

즉, 자바스크립트에서는 함수를 생성할 때, 함수 자신과 연결된 프로토타입 객체를 동시에 생성하며, 이 둘은 각각 `prototype` 과 `constructor` 라는 프로퍼티로 서로를 참조하게 된다.

함수의 `prototype` 프로퍼티가 가리키는 프로토타입 객체는 일반적으로 따로 네이밍하지 않고, 자신과 연결된 함수의 `prototype` 프로퍼티값을 그대로 이용한다. 예를 들어, `add()` 함수의 프로토타입 객체는 `add.prototype` 이 된다.

```javascript
// MyFunction() 함수 정의 - 1
function myFunction() {
    return true;
}
console.dir(myFunction.prototype);	// - 2
console.dir(myFunction.prototype.constructor);	// - 3
```

1. 우선 `myFunction()` 이라는 함수를 생성했다. 함수가 생성됨과 동시에 `myFunction()` 함수의 `prototype` 프로퍼티에는 이 함수와 연결된 프로토타입 객체가 생성된다.

2. `myFunction.prototype` 은 `myFunction()` 함수의 프로토타입 객체를 가리킨다. 크롬 브라우저에서의 결과값으로 프로토타입 객체의 구조를 살펴보자.

   실행결과를 보면 알 수 있듯이 `myFunction.prototype` 객체는 `constructor` 와 `__proto__` 라는 두 개의 프로퍼티가 있다. 앞서 설명했듯이 이 객체는 `myFunction()` 함수의 프로토타입 객체이므로 `constructor` 프로퍼티가 있음을 확인할 수 있다.

   또한, 프로토타입 객체 역시 자바스크립트 객체이므로 자신의 부모 역할을 하는 `__proto__` 프로퍼티가 있다.

3. `myFunction.prototype.constructor` 의 값을 출력함으로써 프로토타입 객체와 매핑된 함수를 알아볼 수 있다. 결과값을 보면 `myFunction()` 함수를 가리키고 있다.



## 3. 함수의 다양한 형태

### 3.1 콜백 함수

자바스크립트 _함수 표현식_ 에서 _함수 이름_ 은 꼭 붙이지 않아도 되는 선택 사항이다. 즉, 함수의 이름을 지정하지 않아도 함수가 정의되며 이러한 함수가 _익명 함수_ 라고 이미 설명했다. 이러한 __익명 함수의 대표적인 용도__ 가 바로 __콜백 함수__ 이다. 콜백 함수는 코드를 통해 명시적으로 호출하는 함수가 아니라, __개발자는 단지 함수를 등록하기만 하고, 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수__ 를 말한다. 또한, __특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수__ 또한 콜백 함수가 될 수 있다.

대표적인 예로 __자바스크립트에서의 이벤트 핸들러 처리__ 를 들 수 있다. DOM 이벤트가 발생할 경우, 브라우저는 정의된 DOM 이벤트에 해당하는 이벤트 핸들러를 실행시킨다. 만약 이러한 이벤트 핸들러에 콜백 함수가 등록됐다면, 콜백 함수는 이벤트가 발생할 때마다 브라우저에 의해 실행된다.

다음 코드를 살펴보자. `window.onload` 는 이벤트 핸들러로서, 웹 페이지의 로딩이 끝나는 시점에 `load` 이벤트가 발생하면 실행된다. 예제에서는 익명 함수가 콜백 함수로 등록되었다.

```html
<!DOCTYPE html>
<html>
<body>
	<script>
   		// 페이지 로드 시 호출될 콜백 함수
        window.onload = function() {
            alert('This is the callback function.');
        }
	</script>   
</body>
</html>
```



### 3.2 즉시 실행 함수

함수를 정의함과 동시에 바로 실행하는 함수를 __즉시 실행 함수__ 라고 한다. 이 함수도 익명 함수를 응용한 형태이다.

```javascript
(function (name) {
    console.log('This is the immediate function -> ' + name);
})('foo');
```

즉시 실행 함수를 만들기 위해 우선 함수 리터럴을 괄호`()` 로 둘러싼다. 이때 함수 이름의 유무는 상관없다. 고라호 안에 값을 추가해 즉시 실행 함수의 인자로 넘길 수가 있다.

이렇게 함수가 선언되자마자 실행되게 만든 즉시 실행 함수는 같은 함수를 다시 호출할 수 없다. 따라서 이런 특징을 이용해 __최초 한 번의 실행만을 필요로 하는 초기화 코드 부분__ 에 유용하게 사용할 수 있다.

즉시 실행 함수는 jQuery와 같은 자바스크립트 라이브러리나 프레임워크 소스들에도 사용된다. 

```javascript
(function (window, undefined) {
    ...
})(window);
```

이렇게 jQuery에서 즉시 실행 함수를 사용하는 이유는 __자바스크립트의 변수 유효 범위__ 특성 때문이다. 기본적으로 자바스크립트는 변수를 선언할 경우 프로그램 전체에서 접근할 수 있는 __전역 유효 범위__ 를 가진다. 그러나 함수 내부에서 정의된 매개변수와 변수들은 __함수 코드 내부에서만 유효__ 할 뿐 함수 밖에서는 유효하지 않다. (이때 변수들은 var로 정의되어야 한다.)

따라서 라이브러리 코드를 즉시 실행 함수 내부에 정의해두게 되면, 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없으며 전역 네임스페이스를 더럽히지 않게 된다.



### 3.3 내부 함수

함수 코드 내부에서도 다시 함수 정의가 가능하다. 이렇게 함수 내부에 정의된 함수를 __내부 함수__ 라고 부른다. 내부 함수는 자바스크립트의 기능을 보다 강력하게 해주는 _클로저_ 를 생성하거나 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 _헬퍼 함수_ 를 구현하는 용도 등으로 사용한다.

```javascript
// parent() 함수 정의
function parent() {
    var a = 100;
    var b = 200;
    
    // child() 내부 함수 정의
    function child() {
        var b = 300;
        
        console.log(a);	// - 1
        console.log(b);	// - 2
    }
    
    child();	// - 3
}

parent();
child();	// - 4
```

```javascript
// 출력 결과
100
300
Uncaught ReferenceError: child is not defined
```

#### 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다.

1. `child()` 내부 함수에 변수 `a` 가 선언되지 않았음에도 3에서  `child()` 함수가 호출됐을 때 값이 100이 출력된다. 이것은  `parent()` 함수의 변수 `a` 값에 접근하여 출력했기 때문이다.
2. 반면에 변수 `b` 는  `child()` 함수에 선언이 되어 있으므로  `parent()` 함수의  `b` 변수가 아닌  `child()` 함수의  `b` 값이 바로 출력됐다.

이것이 가능한 이유는 자바스크립트의 __스코프 체이닝__ 때문이다. __스코프 체이닝__ 때문에, __함수 내부에서는 함수 밖에서 선언된 변수나 함수의 접근이 가능하다.__ 즉, __내부 함수는 자신을 둘러싼 외부 함수의 변수에 접근 가능하다.__ 



#### 내부 함수는 일반적으로 자신이 정의된 부모 함수 내에서만 호출이 가능하다.

4. 앞 예제에서는 `parent()` 함수 외부에서 `child()` 함수 호출을 시도하지만, 함수가 정의되어 있지 않다는 에러가 발생한다. 이것은 자바스크립트의 __함수 스코핑__ 때문이다. __함수 스코프 밖에서는 함수 스코프 안에 선언된 모든 변수나 함수에 접근이 불가능하다.__ 즉, 함수 내부에 선언된 변수는 함수 외부에서 접근이 불가능하다. 

   이 규칙은 내부 함수도 그대로 적용된다. 때문에 부모 함수 외부에서 내부 함수를 호출하는 것이 불가능하다. 반면에 3과 같이 부모 함수 안에서는 `child()` 내부 함수를 호출하는 것은 가능하다. 내부 함수를 호출하는 부분과 내부 함수가 정의된 부분이 모두 부모 함수 내부에 있기 때문이다.



하지만 함수 외부에서도 특정 함수 스코프 안에 선언된 내부 함수를 호출할 수 있다. 예를 들어, 부모 함수에서 내부 함수를 외부로 리턴하면, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.

```javascript
function parent() {
    var a = 100;
    
    // child() 내부 함수 - 1
    var child = function() {
        console.log(a);
    }
    
    // child() 함수 반환
    return child;
}

var inner = parent();	// - 2
inner();	// - 3
```

1. 내부 함수를 _함수 표현식_ 으로 정의하고, `child` 함수 변수에 저장했다. 그리고 `parent()` 함수의 리턴값으로 내부 함수의 참조값을 가진 `child` 함수 변수를 리턴했다.
2. `parent()` 함수가 호출되면, `inner` 변수에 `child` 함수 변수 값이 리턴된다. `child` 함수 변수는 내부 함수의 참조값이 있으므로, 결국 `inner` 변수도 `child()` 내부 함수를 참조한다.
3. 때문에, `inner` 변수에 함수 호출 연산자 `()` 를 붙여 함수 호출 구문을 만들면, `parent()` 함수 스코프 밖에서도 내부 함수 `child()` 가 호출된다. 호출하는 내부 함수에는 `a` 변수가 정의되어 있지 않아, __스코프 체이닝__ 으로 부모 함수에 `a` 변수가 정의되어 있는지 확인하게 되고, `a` 가 정의되어 있으면 그 값이 그대로 출력된다.

이와 같이 실행이 끝난 `parent()` 와 같은 부모 함수 스코프의 변수를 참조하는 `inner()` 와 같은 함수를 __클로저__ 라고 한다.



### 3.4 함수를 리턴하는 함수

자바스크립트에서는 __함수도 일급 객체__ 이므로 일반 값처럼 함수 자체를 리턴할 수도 있다. 이런 특징은 다양한 활용을 가능케한다. _함수를 호출함과 동시에 다른 함수로 바꾸거나_, _자기 자신을 재정의하는 함수를 구현_ 할 수도 있다. 

```javascript
// self() 함수
var self = function() {
    console.log('a');
    return function() {
        console.log('b');
    }
}
self = self();	// a - 1
self();			// b - 2
```


## 4. 함수 호출과 this

### 4.1 `arguments` 객체


출처 : 인사이드 자바스크립트 4. 함수와 프로토타입 체이닝
