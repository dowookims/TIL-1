# 10. 그래프

## 2. 그래프의 표현

### 1) 인접 행렬(Adjacency Matrix)

#### 원리

가중치가 없는 무향 그래프 $G=(V, E)$에서 정점의 총수가 $n$이라 하자. 우선 $n \times n$ 행렬을 준비한다. 정점 $i$와 정점 $j$ 간에 간선이 있으면  행렬의 $(i, j)$ 원소와 $(j, i)$ 원소의 값을 1로 할당한다. 간선으로 연결된 두 정점은 인접한다(*Adjacent*)고 한다. 이런 식으로 모든 간선에 대해서 행렬의 해당 원소에 1을 할당하고, 나머지 원소에는 0을 할당한다.



- 가중치 X 무향 그래프

- 가중치 O 무향 그래프

- 가중치 X 유향 그래프

- 가중치 O 유향 그래프



#### 장단점

* 장점

  * 이해하기 쉽고 간선의 존재 여부를 즉각 알 수 있다

    정점 $i$와 정점 $j$의 인접 여부는 행렬의 $(i, j)$ 원소나 $(j, i)$ 원소의 값만 보면 알 수 있다.

  * **간선의 밀도가 아주 높은 그래프**에서는 인접 행렬 표현이 적절하다.

* 단점

  * $n \times n$ 행렬이 필요하므로 $n^2$에 비례하는 공간이 필요하고, 행렬의 준비 과정에서 행렬의 모든 원소를 채우는 데만 $n^2$에 비례하는 시간이 든다.

    그러므로 $O(n^2)$ 미만의 시간이 소요되는 알고리즘이 필요한 경우에 인접 행렬을 사용하면 행렬의 준비 과정에서만 $\Theta(n^2)​$의 시간을 소모해버려 적절하지 않다.



### 2) 인접 리스트(Adjacency List)

#### 원리

각 정점마다 리스트를 하나씩 만든다. 여기에 각 정점에 인접한 정점들을 연결 리스트로 매단다. 인접 리스트는 인접 행렬과 달리 존재하지 않는 간선은 표현상에 나타나지 않는다.



#### 장단점

* 장점

  * 인접 리스트는 공간이 간선의 총수에 비례하는 양만큼 필요하므로 대체로 행렬 표현에 비해 공간의 낭비가 없다.

    모든 가능한 정점 쌍에 비해 간선의 수가 적을 때 특히 유용하다.

* 단점

  * 거의 모든 정점 쌍에 대해 간선이 존재하는 경우에는 오히려 리스트를 만드는 데 필요한 오버헤드만 더 든다.

  * 인접 리스트는 정점 $i$와 정점 $j$ 간에 간선이 존재하는지 알아볼 때 리스트에서 차례대로 훑어야 하므로 인접 행렬 표현보다는 시간이 많이 걸린다. 

    특히 간선이 많은 경우에는 최악의 경우 $n$ 에 비례하는 시간이 들 수도 있다. 그래서 간선의 밀도가 아주 높은 경우에는 그리 적합하지 않다.



### 3) 인접 배열과 인접 해시 테이블





## 3. 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)

### 1) 너비 우선 탐색(BFS)

#### 알고리즘

1. 먼저 시작 정점을 제외한 모든 정점을 "방문하지 않았다 (`visited[v] = NO`)" 로 표시한다. 
2. 큐의 맨 앞에 있는 정점을 빼내고 이에 인접한 정점 중 방문하지 않은 정점으로 모두 "방문하였다 (`visited[v] = YES`)"로 표시하고 큐에 넣는다.
3. BFS가 수행되는 동안 `enqueue()`와 `dequeue()`를 정확히 $V$번씩 호출한다. 즉, 각 정점이 큐에 한 번씩 들어갔다가 나온다.

* BFS의 수행시간은 $\Theta(V + E)$ 이다.



```pseudocode
BFS(G, s)
{
    for each v ∈ V-{s}
    	visited[v] = NO
    visited[s] = YES		# s : 시작 정점
    enqueue(Q, s)			# Q : 큐
    while (Q != ∅) {
        u = dequeue(Q)
        for each v ∈ L(u)	# L(u) : 정점 u의 인접 정점 집합
        	if (visited[v] == NO) then {
                visited[v] = YES
                enqueue(Q, v)
        	}
    }
}
```





### 2) 깊이 우선 탐색(DFS)

#### 알고리즘

1. 정점 $v$에 대해 `aDFS(v)`가 호출되면 먼저 정점 v를 "방문하였다(`visited[v]=YES`)"로 표시하고 이와 인접한 정점 중 방문하지 않은 정점에 대해 각각 `aDFS`를 호출한다.
2. 정점 v에 인접한 정점 중 방문하지 않은 정점 x, y, z가 있더라도 x에 대해 `aDFS`를 호출하면 `aDFS`는 일단 깊이 들어갈 수 있는 데까지 들어가기 때문에 정점 y나 정점 z가 다른 정점과 인접하면 방문될 수도 있다.

* 즉, `aDFS(v)`에서 x에 대해 `aDFS`를 끝내고 돌아오면 방문하지 않은 상태였떤 정점 y나 정점 z가 방문된 상태가 되어 이들에 대해 `aDFS`를 수행할 필요가 없게 되는 상황은 매우 흔하다.

* 궁극적으로 모든 정점에 대해 `aDFS()`가 한 번씩 호출된다.

* DFS의 수행 시간은 $\Theta(V+E)$이다.



```pseudocode
DFS(G)
{
    for each v ∈ V
    	visited = NO
    for each v ∈ V
    	if (visited[v] == NO) then aDFS(v)
}

aDFS(v)
{
    visited[v] = YES
    for each x ∈ L(v)	# L(v) : 정점 v의 인접 정점 집합
    	if (visitd[x] == NO) then aDFS(x)
}
```





## 5. 위상 정렬(Topological Sorting)

그래프의 모든 간선에 대해서 **작업 $i$와 작업 $j$ 사이에 간선 $(i, j)$가 존재한다면 작업 $i$는 반드시 작업 $j$보다 먼저 수행된다**는 성질이 만족된다고 가정해보자. 이런 성질을 만족하는 정렬을 위상 정렬이라고 한다.

위상 정렬은 **사이클이 없는 유향 그래프** $G=(V, E)$에서 $V$의 모든 정점을 정렬하되 다음 성질을 만족해야 한다.

>  **간선 $(i, j)$가 존재하면 정렬 결과에서 정점 $i$는 반드시 정점 $j$보다 앞에 위치해야 한다.**



#### 용어 정리

* 정점 u의 진입 간선 : u에 연결된 간선 중 u로 향하는 간선
* 정점 u의 진출 간선 : u에 연결된 간선 중 u에서 나가는 간선



#### 위상 정렬 알고리즘 1 - for 루프

```pseudocode
topologicalSort1(G, v)
{
    for i from 1 to n {
        진입 간선이 없는 정점 u를 선택한다;
        A[i] = u;
        정점 u와 u의 진출 간선들을 모두 제거한다;
    }
    # 이 시점에 배열 A[1...n]에는 정점들이 위상 정렬되어 있다.
}
```

여기서 정점이 제거되는 순서가 하나의 위상 정렬을 이룬다.

위상 정렬 알고리즘의 수행 시간을 분석해보자. for 루프는 n번 반복된다. 매 반복 때마다 1개의 정점이 선택되고 해당 정점에서 연결된 진출 간선이 모두 제거된다. 각 간선은 단 한 번씩만 취급된다. 그러므로 총 수행 시간은 $\Theta(V+E)​$이다. 



#### 위상 정렬 알고리즘 2 - DFS

이 알고리즘은 DFS를 거의 그대로 사용하면서 약간의 요소만 더 추가되었다. 앞의 첫 번째 알고리즘은 좀 더 직관적인 접근이나, 두 번째 알고리즘이 더 세련되고 많이 사용된다.

DFS와 다른 점은 함수의 맨 끝에 작업이 끝난 정점을 연결 리스트로 관리하는 부분이다. 알고리즘이 끝나고 나서 연결 리스트 R에 매달린 순서가 위상 정렬된 순서다.

```pseudocode
topologicalSort2(G)
{
    for each v ∈ V
    	visited[v] = NO
    for each v ∈ V
    	if (visited[v] == NO) then DFS-TS(v)
}

DFS-TS(v)
{
    visited[v] = YES
    for each x ∈ L(v)
    	if (visited[v] == NO) then DFS-TS(x)
    연결 리스트 R의 맨 앞에 정점 v를 삽입한다.
}
```

