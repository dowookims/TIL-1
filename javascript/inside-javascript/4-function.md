# 4. 함수와 프로토타입 체이닝

## 4.1 함수 정의

#### 함수 생성 방법

1. 함수 선언문 function statement
2. 함수 표현식 function expression
3. Function() 생성자 함수

이들 방식은 모두 같은 함수를 생성하지만, 각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.

먼저 함수 선언문과 함수 표현식에서 함수를 생성하는 _함수 리터럴_의 개념을 먼저 살펴보자.



### 4.1.1 함수 리터럴

자바스크립트에서 함수도 _일반 객체_처럼 값으로 취급된다. 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, __함수 리터럴__을 이용해 함수를 생성할 수 있다. 함수 선언문과 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 선언한다.

```javascript
function add(x, y) {
    return x + y;
}
```

1. `function` 키워드 : 자바스크립트 함수 리터럴은 `function` 키워드로 시작한다.

2. 함수명 `add`

   함수명은 함수 몸채의 내부 코드에서 자신을 재귀적으로 호출하거나 자바스크립트 디버거가 해당 함수를 구분하는 식별자로 사용된다. 여기서 주목할 점은 __함수명은 선택 사항__이라는 것이다. 자바스크립트에서 _함수명이 없는 함수_를 _익명 함수_라 한다.

3. 매개변수 리스트 `(x, y)` : 매개변수 타입을 기술하지 않는다.

4. 함수 몸체 : 실제 함수가 호출됐을 때 실행되는 코드 부분이다.



### 4.1.2 함수 선언문 방식으로 함수 생성하기

함수 선언문 방식은 앞서 설명한 함수 리터럴 형태와 같다. 주의할 점은 함수 선언문 방식으로 정의된 함수의 경우 __반드시 함수명이 정의되어 있어야 한다__는 것이다.

```javascript
// add() 함수 선언문
function add(x, y) {
    return x + y;
}

console.log(add(3, 4));	// 7
```



### 4.1.3 함수 표현식 방식으로 함수 생성하기

자바스크립트에서는 함수도 _하나의 값_처럼 취급된다. (이러한 특징으로 인해 _일급 객체_로 불리기도 한다.) 따라서 함수도 숫자나 문자열처럼 _변수에 할당_하는 것이 가능하다.

이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 __함수 표현식__이라고 말한다.

```javascript
// add() 함수 표현식 (익명 함수를 변수 add에 할당)
var add = function(x, y) {
    return x + y;
};

var plus = add;

console.log(add(3, 4));		// 7
console.log(plus(5, 6));	// 11
```

__함수 변수__ `add` 가 실제로 참조하는 두 수를 더하는 함수의 이름이 없다. 이렇게 이름이 없는 함수 형태를 __익명 함수__라고 부른다.  즉, 위의 코드는 __익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)__이다.

참고로, 함수 이름이 포함된 함수 표현식을 __기명 함수 표현식__이라 한다.

```javascript
var add = function sum(x, y) {
    return x + y;
};

console.log(add(3, 4));		// 7
console.log(sum(3, 4));		// Uncaught ReferenceError
```

함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능하다는 사실에 주의해야 한다.

함수 표현식에서 함수 이름은 선택 사항이지만, 이러한 함수 이름을 사용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능해진다.

```javascript
var factorialVar = function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

console.log(factorialVar(3));	// 6
console.log(factorial(3));		// undefined
```



#### [참고] 함수 선언문과 함수 표현식에서의 세미콜론

일반적으로 _함수 선언문 방식으로 선언된 함수_의 경우 _세미콜론을 붙이지 않지만_, _함수 표현식 방식_의 경우 _세미콜론을 붙이는 것을 권장_한다.



### 4.1.4 Function() 생성자 함수를 통한 함수 생성하기

자바스크립트의 함수도 `Function()` 이라는 기본 내장 생성자 함수로부터 생성된 __객체__라고 볼 수 있다. 앞서 설명한 함수 선언문이나 함수 표현식 방식은 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로는 `Function()` 생성자 함수로 함수가 생성된다고 볼 수 있다.

`Function()` 생성자 함수로 함수를 생성하는 문법은ㅇ 다음과 같다.

```javascript
new Function (arg1, arg2, ... argN, functionBody)
/* arg1, arg2, ... argN : 함수의 매개변수
   functionBody : 함수가 호출될 때 실행될 코드를 포함한 문자열 */
```

이 방식을 사용해서 작성한 `add()` 함수는 다음과 같다.

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3, 4));	// 7
```



### 4.1.5 함수 호이스팅

지금까지 자바스크립트에서 함수를 생성하는 3가지 방법을 살펴봤다. 모두 같은 기능의 함수를 생성하지만 이들의 동작 방식에는 약간의 차이가 있다. 그중 하나가 바로 __함수 호이스팅__이다.

자바스크립트 Guru로 알려진 더글러스 크락포트는 함수 생성에 있어서 그의 저서 "더글라스 크락포드의 자바스크립트 핵심 가이드"(2008, 한빛미디어)에서 _함수 표현식_만을 사용할 것을 권하고 있다. 그 이유 중 하나가 바로 함수 호이스팅 때문이다.

```javascript
add(2, 3);	// 5	- 1

// 함수 선언문 형태로 add() 함수 정의	- 2
function add(x, y) {
    return x + y;
}

add(3, 4);	// 7	- 3
```

1. 아직 이 시점에서는 함수가 정의되지 않았음에도 `add()` 함수를 호출하는 것이 가능하다. 이것은 함수가 자신이 위치한 코드에 상관없이 __함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다__는 것을 확인할 수 있다. 이것을 __함수 호이스팅__이라 부른다.

더글러스는 이러한 함수 호이스팅은 함수를 사용하기 전에 반드시 선언해야 한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수도 있다고 지적하며, 함수 표현식 사용을 권장하고 있다.

```javascript
add(2, 3);	// uncaught type error	- 1

// 함수 표현식 형태로 add() 함수 정의	- 2
var add = function(x, y) {
    return x + y;
};

add(3, 4);	// 7					- 2
```

1. `add()` 함수는 2에서 함수 표현식 형태로 정의되어 있어 __호이스팅이 일어나지 않는다.__ 따라서 3과 같이 함수가 생성된 이후에 호출이 가능하다.



이러한 함수 호이스팅이 발생하는 원인은 자바스크립트의 __변수 생성(Instantiation)__과 __초기화(Initialization)__의 작업이 분리돼서 진행되기 때문이다.



## 4.2 함수 객체 : 함수도 객체다

### 4.2.1 자바스크립트에서는 함수도 객체다

자바스크립트에서는 __함수도 객체__다. 즉, 함수의 기본 기능인 코드 실행뿐만 아니라 함수 자체가 _일반 객체처럼 프로퍼티들을 가질 수 있다_는 것이다.

```javascript
// 함수 선언문 방식으로 add() 함수 정의 - 1
function add(x, y) {
    return x + y;
}

// add() 함수 객체에 프로퍼티 추가		- 2
add.result = add(3, 2);
add.status = 'OK';

console.log(add.result);	// 5
console.log(add.status);	// 'OK'
```

1. `add()` 함수를 생성할 때 함수 코드는 함수 객체의 __`[[Code]]` 내부 프로퍼티__에 자동으로 저장된다. 

2. 일반 객체처럼 `add()` 함수에 프로퍼티를 동적으로 생성한다.
3. 일반 객체처럼 프로퍼티에 접근한다.



### 4.2.2 자바스크립트에서 함수는 값으로 취급된다.

앞서 설명한 것처럼 자바스크립트에서 함수는 객체다. 이는 __함수도 일반 객체처럼 취급될 수 있다__는 것을 말한다. 때문에 자바스크립트 함수는 다음과 같은 동작이 가능하다.

* 리터럴에 의해 생성
* 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
* 함수의 인자로 전달 가능
* 함수의 리턴값으로 리턴 가능
* 동적으로 프로퍼티를 생성 및 할당 가능

이와 같은 특징을 가진 자바스크립트의 함수는 __일급 객체(First-class object)__로 불린다. 앞에서 나열한 기능이 모두 가능한 객체를 일급 객체라고 부르는데, 자바스크립트 함수가 갖는 이런 일급 객체의 특성으로 _함수형 프로그래밍_이 가능하다.



#### 4.2.2.1 변수나 프로퍼티의 값으로 할당

함수는 숫자나 문자열처럼 _변수나 프로퍼티의 값으로 할당_될 수 있다.

```javascript
// 변수에 함수 할당
var foo = 100;
var bar = function() { return 100; };
console.log(bar());		// 100

// 프로퍼티에 함수 할당
var obj = {};
obj.baz = function() { return 200; };
console.log(obj.baz());	// 200
```



#### 4.2.2.2 함수 인자로 전달

함수는 다른 함수의 인자로도 전달이 가능하다. `foo()`는 함수 표현식 방법으로 생성한 함수로서, 인자로 받은 `func` 함수를 내부에서 함수 호출 연산자 `()`를 붙여 호출하는 기능을 한다.

```javascript
// 함수 표현식으로 foo() 함수 생성
var foo = function(func) {
    func();	// 인자로 받은 func() 함수 호출
};

// foo() 함수 호출
foo(function() {
    console.log('Function can be used as the argument.');
});

// 출력결과
// Function can be used as the argument.
```

위 코드에서 `foo()` 함수를 호출할 때, 함수 리터럴 방식으로 생성한 __익명 함수__를 `func` 인자로 넘겼다. 따라서 `foo()` 함수 내부에서는 `func` 매개변수로 인자에 넘겨진 함수를 호출할 수 있다.



#### 4.2.2.3 리턴값으로 활용

함수는 다른 함수의 리턴값으로도 활용할 수 있다. 다음 예제에서 `foo()`함수는 간단한 익명 함수를 리턴하는 역할을 한다. 이것이 가능한 이유 또한 함수 자체가 값으로 취급되기 때문이다.

```javascript
// 함수를 리턴하는 foo() 정의
var foo = function() {
    return function() {
        console.log('This function is the return value');
    };
};

var bar = foo();	// - 1
bar();				// - 2

// 출력결과
// This function is the return value
```

1. `foo()` 함수가 호출되면, 리턴값으로 전달되는 함수가 `bar` 변수에 저장된다.
2. `()` 함수 호출 연산자를 이용해 `bar()` 로 리턴된 함수를 실행하는 것이 가능하다.



### 4.2.3 함수 객체의 기본 프로퍼티

계속 강조했듯이 자바스크립트에서는 __함수 역시 객체다.__ 이것은 함수 역시 __일반적인 객체의 기능에 추가로 호출됐을 때 정의된 코드를 실행하는 기능을 가지고 있다는 것__이다. 또한, _일반 객체와는 다르게_ 추가로 __함수 객체만의 표준 프로퍼티__ 가 정의되어 있다. 

```javascript
function add(x, y) {
    return x + y;
}
console.dir(add);
```

앞의 코드를 크롬 브라우저에서 실행해보면 `add()` 함수는 `arguments`, `caller`, `length` 등과 같은 다양한 프로퍼티가 기본적으로 생성된 것을 확인할 수 있다. 이러한 프로퍼티들이 함수를 생성할 때 포함되는 _표준 프로퍼티_다.

ECMA5Script 명세서에는 __모든 함수가 `length`와 `prototype` 프로퍼티를 가져야 한다__고 기술하고 있다. 

우선, `length`나 `prototype` 이외의 `name`, `caller`, `arguments`, `__proto__` 프로퍼티를 간단히 살펴보자. 이들 프로퍼티는 __EMCA 표준이 아니다.__

* __`name` 프로퍼티__는 함수의 이름을 나타낸다. 예제에서는 함수명이 `add`이지만, 만약 이름이 없는 익명 함수라면 `name` 프로퍼티는 빈 문자열이 된다.