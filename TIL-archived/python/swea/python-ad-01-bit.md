## 3. 비트 연산

### 1. 비트 연산자

#### 프로그래밍 언어에서 지원하는 비트 연산자들

* 비트 연산자는 다른 연산자들에 비해 실행 시간을 적게 소요한다.
  * `&` : AND
  * `|` : OR
  * `^` : XOR (같으면 0 다르면 1)
  * `~` : NOT
  * `<<` : Left shift
  * `>>` : Right shift



* 프로그램에서 비트 연산 적용 시 연산 속도를 향상시키거나 메모리를 절약 할 수 있다.

  * ex) 변수에 저장된 양의 정수 값의 홀수와 짝수 판별

    1. 모듈러 연산자 이용 (`N % 2`)

    2. 비트단위 AND(&) 연산 이용 (`N & 1`) 

       *마지막 비트값이 1인지 0인지를 보고 판단*



* `1 << n`
  * `2^n`의 값을 가짐
  * 원소가 `n`개일 경우의 *모든 부분집합의 수*를 의미
  * Power set (모든 부분 집합)
    * 공집합과 자기 자신을 포함한 모든 부분집합
    * _각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산_하면 모든 부분집합의 수가 계산됨



* `i & (1 << j)`

  * 계산 결과는 *i의 j번째 비트가 1인지 아닌지를 의미*

  |              | 7    | 6     | 5    | 4    | 3    | 2    | 1    | 0    |                 |
  | ------------ | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | --------------- |
  | i            | 0    | 1     | 0    | 0    | 1    | 0    | 1    | 0    | 2^6 + 2^3 + 2^1 |
  | i << 6       | 0    | **1** | 0    | 0    | 0    | 0    | 0    | 0    | 2^6             |
  | i & (1 << 6) | 0    | **1** | 0    | 0    | 0    | 0    | 0    | 0    | 2^6             |



### 2. 비트 연산 예제

#### 1) 비트 연산 1

특정 위치의 비트값을 확인하는 수식

```python
# 8비트의 문자형 변수에 저장된 비트값을 출력하는 함수
def BitPrint(i):
    for j in range(7, -1, -1):
        print('1' if (i & (1 << j)) else '0', end='')
        # print('%d' % ((i >> j) & 1), end='')

for i in range(-5, 6):
    print('%2d = ' % i, end='') # 10진수 출력
    BitPrint(i)					# 2진수 출력
    print()
```

```python
# 결과
-5 = 11111011
-4 = 11111100
-3 = 11111101
-2 = 11111110
-1 = 11111111
 0 = 00000000
 1 = 00000001
 2 = 00000010
 3 = 00000011
 4 = 00000100
 5 = 00000101
```



#### 2) 비트 연산 2

4바이트 크기의 int 변수에 저장된 값을 1바이트씩 읽어서 비트 형태로 출력

```python
a = 0x10 					# 16진수	0x10
x = 0x01020304
print('%d = ' % a, end='')	# 2진수	0b00010000
BitPrint(a)
print()
print('%08x = ' % x, end='')
for i in range(0, 25, 8):
    BitPrint(x >> i)
    print(end=' ')
```



### 3. 엔디안

#### 1) 엔디안

* 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다름
* 주의 사항
  * 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있음
* 빅 엔디안 (Big-endian)
  * 보통 큰 단위 (MSB)가 앞에 나옴
  * 네트워크
* 리틀 엔디안 (Little-endian)
  * 작은 단위 (LSB)가 앞에 나옴
  * 대다수 데스크탑 컴퓨터

| 종류        | 0x1234 | 0x12345678  |
| ----------- | ------ | ----------- |
| 빅 엔디안   | 12 34  | 12 34 56 78 |
| 리틀 엔디안 | 34 12  | 78 56 34 12 |



#### 2) 비트 연산 3

자신의 컴퓨터가 어떤 엔디안 방식인지 확인하는 코드

```python
n = 0x00111111
if n & 0x11:	# c = [11, 11, 11, 00]
    print('little endian')
else:			# c = [00, 11, 11, 11]
    print('big endian')
```



#### 3) 비트 연산 4

비트 연산자 `^`를 두 번 연산하면 처음 값을 반환

```python
a = 0x86
key = 0xAA

print('a : ', end='')
BitPrint(a)
print()

print('a ^= key : ', end='')
BitPrint(a)
print()

print('a ^= key : ', end='')
BitPrint(a)
print()
```

XOR 연산자 (`^`) 를 사용해서 변환된 값은 다시 XOR 연산자 (`^`) 를 이용해서 복구



출처 : 파이썬 SW문제해결 응용-구현 01 시작하기