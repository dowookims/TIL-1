# 고급 정렬 알고리즘

* 병합 정렬
* 퀵 정렬
* 힙 정렬

모두 평균 $\Theta(nlogn)​$ 의 시간이 소요된다.

최악의 경우에도 병합 정렬과 힙 정렬은 $\Theta(nlogn)​$ 이 소요되고, 퀵 정렬은 $\Theta(n^2)​$ 이 소요된다.



## 1) 퀵 정렬 (Quick Sort)

병합 정렬과 마찬가지로, 퀵 정렬은 **Divide and Conquer** 알고리즘입니다. 한 원소를 pivot으로 고른 뒤 pivot을 기준으로 주어진 배열을 나눕니다. pivot을 고르는 방법에 따라 여러 가지 퀵 정렬이 존재합니다.

* pivot을 고르는 다양한 방법
  * 항상 첫 번째 원소를 pivot으로 고른다.
  * 항상 마지막 원소를 pivot으로 고른다. (아래 구현되어 있습니다.)
  * 랜덤으로 pivot 원소를 고른다.
  * 중간값 원소를 pivot으로 고른다.

퀵 정렬의 핵심 프로세스는 `partition()` 입니다. `partition()` 은 주어진 배열에서 pivot 원소 x를



## 2) 병합 정렬 (Merge Sort)

퀵 정렬과 마찬가지로, 병합 정렬은 **Divide and Conquer** 알고리즘입니다. 입력 배열을  반으로 나눈 다음 각각에 대해 또 반으로 나누고 정렬된 배열을 병합합니다. 

`merge()` 함수는 반으로 나눠진 두 배열을 병합하기 위해 사용합니다. `merge(arr, l, m, r)` 은 `arr[l...m]`과 `arr[m+1...r]`이 이미 정렬된 상태임을 가정하며 두 개의 정렬된 배열을 하나의 배열로 병합합니다.

```pseudocode
MergeSort(arr[], l, r)
{
    if r > l
    	1. arr의 중간점을 기준으로 arr을 반으로 나눕니다.
    	   중간점 m = (l+r) / 2
    	2. 전반부에 대해 mergeSort를 호출합니다.
    	   mergeSort(arr, l, m)
    	3. 후반부에 대해 mergeSort를 호출합니다.
    	   mergeSort(arr, m+1, r)
    	4. 2와 3에서 정렬된 두 부분배열을 하나로 합칩니다.
    	   merge(arr, l, m, r)
}
```





#### 알고리즘

1. 먼저 입력을 반으로 나눈다.
2. 이렇게 나눈 전반부와 후반부를 각각 독립적으로 정렬한다.
3. 마지막으로 정렬된 두 부분을 합쳐서, 즉 병합하여 정렬된 배열은 얻는다.

여기서 전반부와 후반부를 정렬할 때도 역시 반으로 나눈 다음 정렬해서 병합한다. 즉, 병합 정렬은 **자신에 비해 크기가 반인 문제를 두 개 푼 다음, 이들을 병합하는 일**을 **재귀적으로 반복**한다.



```pseudocode
mergeSort(A[], p, r)	# A[p...r]을 정렬한다.
{
    if (p < r) then {
        q = (p + r) // 2	# p, r의 중간 지점 계산
        mergeSort(A, p, q)
        mergeSort(A, q+1, r)
        merge(A, p, q, r)
    }
}

merge(A[], p, q, r)
{
    정렬되어 있는 두 배열 A[p...q]와 A[q+1...r]을 ㅏㅎㅂ쳐
    정렬된 하나의 배열 A[p...r]을 만든다.
}
```



```pseudocode
merge(A[], p, q, r)
# A[p...q]와 A[q+1...r]을 병합하여 A[p...r]을 정렬된 상태로 만든다.
# A[p...q]와 A[q+1...r]은 이미 정렬되어 있다.
{
    i = p
    j = q+1
    t = 1
    while (i <= q and j <= r) {
        if (A[i] <= A[j])
        then tmp[t++] = A[i++]
        else tmp[t++] = A[j++]
    }
    while (i <= q)
    	tmp[t++] = A[i++]
    while (j <= r)
    	tmp[t++] = A[j++]
    i = p
    t = 1
    while (i <= r)
    	A[i++] = tmp[t++]
}
```





출처 : https://www.geeksforgeeks.org/quick-sort/, 쉽게 배우는 알고리즘



출처 : https://www.geeksforgeeks.org/merge-sort/, 쉽게 배우는 알고리즘