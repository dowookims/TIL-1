# 부분 집합

## 1. 부분 집합 문제

#### 부분 집합의 합 문제

유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제

* 완전 검색기법으로 부분 집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분 집합을 생성한 후 각 부분 집합의 합을 계산함
* 주어진 집합의 부분 집합을 생성하는 방법 생각해 보기



#### 부분 집합의 수

* 어떤 집합의 부분 집합을 구할 경우, 부분 집합의 총 개수가 몇 개일까요?
  * 집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 개수는 2^n개
  * 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음



## 2. 부분 집합 문제 알고리즘1

```python
bit = [0, 0, 0, 0]	
for i in range(2):
    bit[0] = i	# 0번째 원소
    for j in range(2):
        bit[1] = j	# 1번째 원소
        for k in range(2):
            bit[2] = k	# 2번째 원소
            for l in range(2):
                bit[3] = l	# 3번째 원소
                print(bit)	# 생성된 부분집합 출력
  
```

* __비트 List__ : 대상 List의 각 원소를 포함할지 말지를 정하는 List



## 3. 부분 집합 문제 알고리즘1

* __비트 연산자__ : 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자
  * &, |, >>, <<

* `1 << n` : 2^n (즉, 원소가 n개일 경우) 
  * 원소가 n개일 경우의 모든 부분 집합의 수를 의미함
* `i & (1 << i)` : 1
  * i에서 j번째 비트가 1인지 아닌지를 리턴함



#### 보다 간결하게 부분 집합을 생성하는 방법

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr) # n: 원소의 개수

for i in range(1 << n): 	# 1 << n : 부분 집합의 개수
    for j in range(n):		# 원소의 수만큼 비트를 비교함
        if i & (i << j):	# i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=",")
    print()
```



출처 : [SW Expert Academy] 파이썬 SW 문제해결 기본 - LIST2